'''Max Set of Gaussian (MSG) landscape generator.
'''

try:
    # Pylint can't import numpy for some reason, so hide the errors
    #pylint: disable=E0611
    from numpy import zeros, random, cos, sin, mat, diag, eye, multiply, exp
    from numpy import max as numpy_max
    #pylint: enable=E0611
    
    #pylint: disable=E1101
    class MaxSetGaussians(object):
        '''MSG class. Initialises covariance, meanvector and optimum values needed.
        '''
        def __init__(self, ndims, ngauss, lower, upper, globalvalue, ratio, seed=1234):
            # keep a copy of the parameters
            self.ndims = ndims    # dimensionality
            self.ngauss = ngauss  # number of gaussian components
            self.upper = upper    # upper boundary
            self.lower = lower    # lower boundary
            self.globalvalue = globalvalue # the value of the global optimum
            self.ratio = ratio    # values of local optima ([0,ratio*globalvalue])
            
            # Make namespace for each gaussian component
            self.covmatrix_inv = [None]*self.ngauss # inverse convariance matrix
            self.meanvector    = None               # mean of each component
            self.optimumvalue  = zeros(self.ngauss) # peak value of each components
            
            # Create a seeded random object for repeatable testing.
            # However - uses the numpy.random module, so seed
            robj = random.RandomState(seed)
            #robj = random.RandomState()
            frand = robj.normal
            rand = robj.rand
            
            # Create the rotation matrix
            tmp_eye = mat(eye(ndims))
            rotation = [ tmp_eye.copy() for i in xrange(ngauss) ]
            
            for i in xrange(ngauss):
                for j in xrange(ndims - 1): # need n(n01)/2 rotation matrices
                    for k in xrange(j + 1, ndims):
                        rotate = tmp_eye.copy()
                        alpha = frand() # normal range of [0,1)
                        rotate[j, j] = cos(alpha)
                        rotate[j, k] = sin(alpha)
                        rotate[k, j] = -sin(alpha)
                        rotate[k, k] = cos(alpha)
                        rotation[i] = rotation[i] * rotate # matrix dot() multiply
            
            # Create the covarianace matrix
            variancerange = (upper-lower)/20 # this controls the range of variance
            #note: rand makes numpy array, which works right with diag() later.
            variance = rand(ngauss, ndims) * variancerange + 0.5
            # add 0.5 to avoid zero
            
            for i in xrange(ngauss):
                covmatrix = mat(diag(variance[i]))
                # matrix multiply (dot) as rotation & covmatrix are type matrix
                covmatrix = rotation[i].T * covmatrix * rotation[i]
                # store the inverse (of the square) covariance matrix
                self.covmatrix_inv[i]  = covmatrix.I
            
            # Generate a set of random mean vectors within the specified range
            self.meanvector = rand(ngauss, ndims) * (upper-lower) + lower
            
            # Assign optima values for each component to the array
            self.optimumvalue[0] = globalvalue # best first
            # - the others get range [0,globalvalue*ratio]
            self.optimumvalue[1:ngauss] = rand(1, ngauss-1) * globalvalue * ratio
        
        
        def eval(self, x):
            '''Evaluate a single individual.
            '''
            # Note - original matlab code tested an entire set of individuals
            # we just test one at a time
            ngauss = self.ngauss
            ndims = self.ndims
            meanvector = self.meanvector
            covmatrix_inv = self.covmatrix_inv
            optimumvalue = self.optimumvalue
            
            # calculate the values generated by each component
            tmp = zeros(ngauss)
            for i in xrange(ngauss):
                newx = x - meanvector[i]
                y = multiply((newx * covmatrix_inv[i]), newx)
                tmp[i] = y.sum()
            
            fitness = exp(-0.5*tmp/ndims)
            fitness = multiply(fitness, optimumvalue.T)
            #components = fitness.T
            fitnessvalue = numpy_max(fitness)
            return fitnessvalue
        
        
        def info(self):
            '''Return parameters and calculated matrix
            '''
            result = []
            result.append('----------------------------------------------')
            result.append('Dimensions: %d' % self.ndims)
            result.append('Components (Gaussians): %d' % self.ngauss)
            result.append('Range (lower,upper): (%f,%f)' % (self.lower, self.upper))
            result.append('Best (global) value: %f' % self.globalvalue)
            result.append('Best-to-rest ratio: %f' % self.ratio)
            result.append('Covmatrix: ...')
            #result.append(self.covmatrix_inv)
            result.append('Meanvector: ...')
            #result.append(self.meanvector)
            result.append('Optimum values: ' + str(self.optimumvalue))
            result.append('----------------------------------------------')
            return result

except ImportError:
    pass
